Постая выборка: 

Данная выборка демонстрирует команды, которые были созданы до 2010-01-01 в порядке возрастания года создания:
SELECT *FROM team WHERE founded < '2010-01-01' order by founded ASC;

Оптимизация:  CREATE INDEX team_founded_index ON team USING HASH (founded);

Sort  (cost=1.15..1.16 rows=3 width=126) (actual time=0.116..0.116 rows=3 loops=1)
   Sort Key: prize_fund DESC
   Sort Method: quicksort  Memory: 25kB
   ->  Seq Scan on championship  (cost=0.00..1.13 rows=3 width=126) (actual time=0.081..0.084 rows=3 loops=1)
         Filter: (end_date < '2016-05-14'::date)
         Rows Removed by Filter: 7
 Planning time: 0.438 ms
 Execution time: 0.184 ms

Данная выборка демонстрирует чемпионаты, даты завершения чемпионата до 2016-05-14, где призовой фонд выбирается в порядке убывания. 
SELECT id AS "Number", name, prize_fund  FROM championship where end_date < '2016-05-14' order by prize_fund DESC;

Оптимизация:  CREATE INDEX championship_end_date_index ON championship USING HASH (end_date);

Sort  (cost=1.15..1.16 rows=3 width=126) (actual time=0.213..0.213 rows=3 loops=1)
   Sort Key: prize_fund DESC
   Sort Method: quicksort  Memory: 25kB
   ->  Seq Scan on championship  (cost=0.00..1.13 rows=3 width=126) (actual time=0.101..0.105 rows=3 loops=1)
         Filter: (end_date < '2016-05-14'::date)
         Rows Removed by Filter: 7
 Planning time: 1.318 ms
 Execution time: 0.364 ms

Данная выборка демонстрирует игроков, дата рождения которых < 1995-01-01, сортируется в порядке убывания, выводятся первые 10 игроков.
SELECT *FROM player WHERE date_of_birth < '1995-01-01' ORDER BY career_start DESC limit 10;

Оптимизация:  CREATE INDEX player_date_of_birth_index ON player (date_of_birth);

Limit  (cost=1.74..1.77 rows=10 width=216) (actual time=0.078..0.080 rows=10 loops=1)
   ->  Sort  (cost=1.74..1.77 rows=13 width=216) (actual time=0.075..0.075 rows=10 loops=1)
         Sort Key: career_start DESC
         Sort Method: top-N heapsort  Memory: 25kB
         ->  Seq Scan on player  (cost=0.00..1.50 rows=13 width=216) (actual time=0.043..0.050 rows=24 loops=1)
               Filter: (date_of_birth < '1995-01-01'::date)
               Rows Removed by Filter: 16
 Planning time: 2.237 ms
 Execution time: 0.141 ms

Данная выборка демонстрирует чемпионаты, призовые фонды не повторяются, а сортируются относительно даты, если есть два похожих призовых фонда по количеству денег, то они сравниваются: выбирается тот, который закончился позже, призовой фонд не может быть меньше 100000.
SELECT DISTINCT ON (prize_fund) name, end_date FROM championship where prize_fund > 100000 ORDER BY prize_fund,end_date ASC;

Оптимизация: CREATE INDEX Championship_prize_fund_index ON championship (prize_fund);

 Unique  (cost=1.15..1.16 rows=3 width=126) (actual time=0.270..0.275 rows=5 loops=1)
   ->  Sort  (cost=1.15..1.16 rows=3 width=126) (actual time=0.266..0.267 rows=7 loops=1)
         Sort Key: prize_fund, end_date
         Sort Method: quicksort  Memory: 25kB
         ->  Seq Scan on championship  (cost=0.00..1.13 rows=3 width=126) (actual time=0.175..0.182 rows=7 loops=1)
               Filter: (prize_fund > 100000)
               Rows Removed by Filter: 3
 Planning time: 1.023 ms
 Execution time: 0.438 m
 
 
Средняя выборка: 

Данная выборка демонстрирует процесс вывода тех команд, которые играли в родных странах на различных чемпионатах, которые закончились позже 2016-01-01, сортируется по занятому месту на чемпионате в порядке возрастания (начиная с первого).

SELECT t.name, t.country, tc.place_of_team, tc.kush_of_team, c.name, c.end_date, c.host_country, c.prize_fund FROM team t 
JOIN teamchampionship 
tc ON t.id = tc.tid 
JOIN championship c 
ON t.country = c.host_country 
AND tc.cid = c.id 
WHERE c.end_date > '2016-01-01'  
ORDER BY tc.place_of_team ASC; 

Оптимизация:  CREATE INDEX team_sireal_id_index ON team (id);
              CREATE INDEX teamchampionship_tid_index ON teamchampionship (tid);
              CREATE INDEX team_country_index ON team (country);
              CREATE INDEX championship_host_country_index ON championship (host_country);
              CREATE INDEX teamchampionship_cid_index ON teamchampionship (cid);
              CREATE INDEX championship_sireal_id_index ON championship (id);
              CREATE INDEX championship_end_date_index ON championship USING HASH (end_date);
              
Sort  (cost=4.25..4.26 rows=2 width=220) (actual time=0.256..0.257 rows=3 loops=1)
   Sort Key: tc.place_of_team
   Sort Method: quicksort  Memory: 25kB
   ->  Hash Join  (cost=2.32..4.24 rows=2 width=220) (actual time=0.226..0.244 rows=3 loops=1)
         Hash Cond: ((tc.tid = t.id) AND (tc.cid = c.id))
         ->  Seq Scan on teamchampionship tc  (cost=0.00..1.52 rows=52 width=16) (actual time=0.037..0.049 rows=52 loops=1)
         ->  Hash  (cost=2.29..2.29 rows=2 width=220) (actual time=0.090..0.090 rows=4 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 9kB
               ->  Hash Join  (cost=1.16..2.29 rows=2 width=220) (actual time=0.078..0.083 rows=4 loops=1)
                     Hash Cond: (t.country = c.host_country)
                     ->  Seq Scan on team t  (cost=0.00..1.08 rows=8 width=86) (actual time=0.015..0.016 rows=8 loops=1)
                     ->  Hash  (cost=1.13..1.13 rows=3 width=134) (actual time=0.048..0.048 rows=10 loops=1)
                           Buckets: 1024  Batches: 1  Memory Usage: 9kB
                           ->  Seq Scan on championship c  (cost=0.00..1.13 rows=3 width=134) (actual time=0.017..0.021 rows=10 loops=1)
                                 Filter: (end_date > '2016-01-01'::date)
 Planning time: 5.119 ms
 Execution time: 0.398 ms

Данная выборка демонстрирует процесс вывода стран и сопоставления ей игроков из команды, которая была создана там, где родился игрок (то есть необязательно, что он состоит в этой команде: одна команда представляет одну страну), команды, которые участвуют в выбоке должны быть созданны после 1990-01-01, формирование происходит в порядке возрастания id страны, выводятся первые 25 команд.
Если место создания команды не совподает с местом рождения игрока, то поля surname и alias будут пусты, и просто выведена строна и соответвующая команда и дата её создания.

SELECT co.name, p.surname, p.alias, t.name, t.founded FROM country co 
JOIN player p 
ON co.id = p.homeland 
JOIN team t 
ON t.country = co.id 
where t.founded > '1990-01-01' 
ORDER BY t.country, t.founded ASC limit 25;

Оптимизация: CREATE INDEX country_sireal_id_index country ON country (id);
             CREATE INDEX player_homeland_index ON player (homeland);
             CREATE INDEX team_country_index ON team (country);
             CREATE INDEX team_founded_index ON team USING HASH (founded);
             
Limit  (cost=4.13..4.15 rows=11 width=360) (actual time=0.190..0.197 rows=25 loops=1)
   ->  Sort  (cost=4.13..4.15 rows=11 width=360) (actual time=0.189..0.190 rows=25 loops=1)
         Sort Key: t.country, t.founded
         Sort Method: quicksort  Memory: 27kB
         ->  Hash Join  (cost=2.36..3.94 rows=11 width=360) (actual time=0.129..0.150 rows=30 loops=1)
               Hash Cond: (p.homeland = co.id)
               ->  Seq Scan on player p  (cost=0.00..1.40 rows=40 width=200) (actual time=0.038..0.042 rows=40 loops=1)
               ->  Hash  (cost=2.32..2.32 rows=3 width=168) (actual time=0.073..0.073 rows=8 loops=1)
                     Buckets: 1024  Batches: 1  Memory Usage: 9kB
                     ->  Hash Join  (cost=1.14..2.32 rows=3 width=168) (actual time=0.059..0.067 rows=8 loops=1)
                           Hash Cond: (co.id = t.country)
                           ->  Seq Scan on country co  (cost=0.00..1.11 rows=11 width=82) (actual time=0.012..0.013 rows=11 loops=1)
                           ->  Hash  (cost=1.10..1.10 rows=3 width=86) (actual time=0.032..0.032 rows=8 loops=1)
                                 Buckets: 1024  Batches: 1  Memory Usage: 9kB
                                 ->  Seq Scan on team t  (cost=0.00..1.10 rows=3 width=86) (actual time=0.016..0.019 rows=8 loops=1)
                                       Filter: (founded > '1990-01-01'::date)
 Planning time: 1.852 ms
 Execution time: 0.281 ms

Данная выборка демонстрирует процесс вывода на экран СМИ и соответствующие ссылки от данной команды, а также видно откуда данная команда выкладывает свои новости: ролики, фотографии, презентации и прочее. Данное сми должно было создано до 2005-05-05, сортировка идёт по имени СМИ (m.name), выводятся первые 15 строк. 

SELECT m.name, m.date_of_create, tm.link, t.name, t.founded, co.name FROM mediaprovider m 
JOIN team_mediaprovider tm 
ON m.id = tm.mpid 
JOIN team t 
ON tm.tid=t.id 
JOIN country co 
ON t.country = co.id 
WHERE m.date_of_create > '2005-05-05' 
ORDER BY t.name ASC 
limit 15;

Оптимизация: CREATE INDEX mediaprovider_serial_id_index ON mediaprovider (id);
             CREATE INDEX team_mediaprovider_mpid_index ON team_mediaprovider (mpid);
             CREATE INDEX team_mediaprovider_tmid_index ON team_mediaprovider (tmid);
             CREATE INDEX team_mediaprovider_tid_index ON team_mediaprovider (tid);
             CREATE INDEX team_serial_id_index ON team (id);
             CREATE INDEX team_country_index ON team (country);
             CREATE INDEX media_provder_date_of_create_index ON mediaprovider USING HASH (date_of_create);

Limit  (cost=5.32..5.35 rows=12 width=400) (actual time=0.353..0.357 rows=15 loops=1)
   ->  Sort  (cost=5.32..5.35 rows=12 width=400) (actual time=0.351..0.355 rows=15 loops=1)
         Sort Key: t.name
         Sort Method: quicksort  Memory: 27kB
         ->  Hash Join  (cost=3.60..5.11 rows=12 width=400) (actual time=0.216..0.234 rows=17 loops=1)
               Hash Cond: (tm.tid = t.id)
               ->  Hash Join  (cost=1.09..2.52 rows=12 width=244) (actual time=0.112..0.125 rows=17 loops=1)
                     Hash Cond: (tm.mpid = m.id)
                     ->  Seq Scan on team_mediaprovider tm  (cost=0.00..1.30 rows=30 width=166) (actual time=0.041..0.045 rows=30 loops=1)
                     ->  Hash  (cost=1.06..1.06 rows=2 width=86) (actual time=0.043..0.043 rows=3 loops=1)
                           Buckets: 1024  Batches: 1  Memory Usage: 9kB
                           ->  Seq Scan on mediaprovider m  (cost=0.00..1.06 rows=2 width=86) (actual time=0.029..0.032 rows=3 loops=1)
                                 Filter: (date_of_create > '2005-05-05'::date)
                                 Rows Removed by Filter: 2
               ->  Hash  (cost=2.41..2.41 rows=8 width=164) (actual time=0.089..0.089 rows=8 loops=1)
                     Buckets: 1024  Batches: 1  Memory Usage: 9kB
                     ->  Hash Join  (cost=1.18..2.41 rows=8 width=164) (actual time=0.059..0.066 rows=8 loops=1)
                           Hash Cond: (co.id = t.country)
                           ->  Seq Scan on country co  (cost=0.00..1.11 rows=11 width=82) (actual time=0.015..0.015 rows=11 loops=1)
                           ->  Hash  (cost=1.08..1.08 rows=8 width=90) (actual time=0.029..0.029 rows=8 loops=1)
                                 Buckets: 1024  Batches: 1  Memory Usage: 9kB
                                 ->  Seq Scan on team t  (cost=0.00..1.08 rows=8 width=90) (actual time=0.018..0.021 rows=8 loops=1)
 Planning time: 3.684 ms
 Execution time: 0.528 m
 

Сложная выборка: 

Найти разницу между максимальным выигрышем команды (по всем) и средней суммой среди всех выигрышей команд, т.е насколько максимальный превышает средний выигрышь.
SELECT
(SELECT MAX(t.kush_of_team) FROM teamchampionship t)
- 
(SELECT FLOOR(AVG(t.kush_of_team)) FROM teamchampionship t) 
AS dif_kush_max_and_avg;

Выборка демонстрирует уникальные имена команд, которые выиграли за один чемпионат большую сумму, нежели минимальный призовой фонд среди всех чемпионатов был разыгран на данное время, выводит имена команд, выигранную сумму, имена чемпионата, на котором был получен куш и место на чемпионате. 
SELECT DISTINCT ON (t.name) t.name, tc.kush_of_team, c.name, tc.place_of_team from team t
JOIN teamchampionship tc ON t.id = tc.tid
JOIN championship c ON tc.cid = c.id
WHERE tc.kush_of_team > (SELECT MIN(prize_fund) FROM championship
ORDER BY t.name, tc.kush_of_team DESC);

Выборка демонстрирует средний возраст игроков и максимальную игровую карьеру среди всех.
SELECT (SELECT FLOOR(AVG(date_part('year',localtimestamp) - date_part('year',player.date_of_birth)))
AS AVG_age from player), 
FLOOR(MAX(date_part('year',localtimestamp) - date_part('year', player.career_start)))
AS MAX_career from player;
